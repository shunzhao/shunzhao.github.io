import{_ as l,c as a,o as i,a3 as t}from"./chunks/framework.Cv3JQ2Vj.js";const d=JSON.parse('{"title":"红黑树","description":"","frontmatter":{"title":"红黑树","date":"2020-07-23T00:00:00.000Z"},"headers":[],"relativePath":"posts/hong-hei-shu.md","filePath":"posts/hong-hei-shu.md"}'),e={name:"posts/hong-hei-shu.md"},o=t('<h1 id="红黑树" tabindex="-1">红黑树 <a class="header-anchor" href="#红黑树" aria-label="Permalink to &quot;红黑树&quot;">​</a></h1><p>红黑树其实是二叉树的一种变体，是为了解决二叉树的一些缺点，那么二叉树有什么缺点呢？</p><p>二叉树很容易造成某一边的树枝无限的增长，比如以下这种情况：</p><p><img src="http://static.zhaoshun.org/image-20200723140644952.png" alt="image-20200723140644952"></p><p>这就导致了树的不平衡，本来使用树是为了介于数组和链表之间性能折中的目的，这下又变成了链表，毫无意义。</p><p>于是红黑树则采用一些策略去努力追求平衡（当然有可能达不到完美的平衡）。</p><h3 id="红黑树规则" tabindex="-1">红黑树规则 <a class="header-anchor" href="#红黑树规则" aria-label="Permalink to &quot;红黑树规则&quot;">​</a></h3><ol><li>新增的节点颜色初始化为红色</li><li>确保根节点一定为黑色，时刻判断自身节点是否为根节点，如果是则修改自身颜色为黑色</li><li>相邻两个的节点不得同时为红色，但可以同时为黑色 <ul><li>相邻节点指的是用过<strong>线连接的两个节点</strong></li></ul></li><li>叶子节点（就是无子孙节点）默认情况下带有两个值为null的黑色节点</li></ol><p>只要你的树满足了以上的规则，就说明这个树的平衡性很不错了，保证了使用树的本来目的。</p><p>但如果你的树不满足以上规则，则需要采取一些操作，使之满足上面的规则。</p><p>于是红黑树提供的操作大致有两种：</p><ol><li>变色</li><li>旋转</li></ol><p>先变色处理，如果变色处理不了，就改为旋转。（也有可能是旋转之后配合变色）</p><h3 id="变色" tabindex="-1">变色 <a class="header-anchor" href="#变色" aria-label="Permalink to &quot;变色&quot;">​</a></h3><p>判断节点的叔叔（父亲的兄弟）是否为红色</p><ul><li><p>是</p><ul><li>将父亲节点和叔叔节点变成黑色</li><li>将祖父节点变成红色，让新增的节点与祖父节点颜色相同</li><li>如果祖父为根节点则违反第二条规则，修改为黑色</li></ul></li><li><p>否</p><ul><li><h3 id="采用旋转规则" tabindex="-1">采用旋转规则 <a class="header-anchor" href="#采用旋转规则" aria-label="Permalink to &quot;采用旋转规则&quot;">​</a></h3></li></ul></li></ul><h3 id="旋转" tabindex="-1">旋转 <a class="header-anchor" href="#旋转" aria-label="Permalink to &quot;旋转&quot;">​</a></h3><p>​ 旋转分为左左、左右、右右、右左。</p><ol><li><p>左左</p><p>新增节点X是左节点，同时父亲节点P也是左节点。</p><ol><li>将P点顶替G点的位置，可以想象一根绳子将P点提了起来</li><li>交换P点和G点的颜色</li></ol><p><img src="http://static.zhaoshun.org/image-20200723163011127.png" alt="image-20200723163011127"></p></li><li><p>左右</p><p>新增节点X是右节点、而父亲节点P是左节点。</p><ol><li>将X移到左节点，同时与P交换。</li><li>做完第一步后，就变成了左左的情况，再按照左左的规则处理</li></ol><p><img src="http://static.zhaoshun.org/image-20200723163539644.png" alt="image-20200723163539644"></p></li><li><p>右右</p><p>新增节点X是右节点，同时父亲节点P也是右节点，与左左正好相反。</p><ol><li>将P点顶替G点的位置，可以想象一根绳子将P点提了起来</li><li>交换P点和G点的颜色</li></ol><p><img src="http://static.zhaoshun.org/image-20200723163823661.png" alt="image-20200723163823661"></p></li><li><p>右左</p><p>新增节点X是左节点、而父亲节点P是右节点。</p><ol><li>将X移到右节点，同时与P交换。</li><li>做完第一步后，就变成了右右的情况，再按照右右的规则处理</li></ol><p><img src="http://static.zhaoshun.org/20200723164008557.png" alt="image-20200723164008557"></p></li></ol><p>最好是自己动手画一画，然后配合该网址理解：<a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html" target="_blank" rel="noreferrer">https://www.cs.usfca.edu/~galles/visualization/RedBlack.html</a></p><p>该网址是在线演示红黑树的变化过程，还可以可以通过底部的Animation Speed滚动条加速或减速变化过程。</p><blockquote><p><a href="https://segmentfault.com/a/1190000020118044" target="_blank" rel="noreferrer">https://segmentfault.com/a/1190000020118044</a></p></blockquote>',22),p=[o];function s(r,h,n,c,u,g){return i(),a("div",null,p)}const _=l(e,[["render",s]]);export{d as __pageData,_ as default};
