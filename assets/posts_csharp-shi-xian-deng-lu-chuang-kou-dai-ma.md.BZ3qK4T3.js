import{_ as s,c as i,o as a,a3 as n}from"./chunks/framework.Cv3JQ2Vj.js";const c=JSON.parse('{"title":"C#实现登陆窗口代码","description":"","frontmatter":{"title":"C#实现登陆窗口代码","date":"2017-04-19T00:00:00.000Z"},"headers":[],"relativePath":"posts/csharp-shi-xian-deng-lu-chuang-kou-dai-ma.md","filePath":"posts/csharp-shi-xian-deng-lu-chuang-kou-dai-ma.md"}'),p={name:"posts/csharp-shi-xian-deng-lu-chuang-kou-dai-ma.md"},l=n(`<h1 id="c-实现登陆窗口代码" tabindex="-1">C#实现登陆窗口代码 <a class="header-anchor" href="#c-实现登陆窗口代码" aria-label="Permalink to &quot;C#实现登陆窗口代码&quot;">​</a></h1><p>最近在写老师布置的项目 写的项目里面需要实现一个登陆窗口</p><p>按照我的想法就是 设置这个登陆窗口为主窗体，登陆验证成功通过后用</p><p>this.Hide();</p><p>来隐藏登陆窗体，最后判断用户实现功能的窗体结束的同时结束主窗体。但这种方法有可能会比较占资源。</p><p>老师的方法是，不用设置登陆窗体为主窗体，只是在打开主窗体之前，先执行登陆窗体代码如下：</p><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   //form1窗体里面</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Form1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        InitializeComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        frmLogin</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> frmLogin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        fl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ShowDialog</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre></div><p>但有个致命的BUG就是，登陆判断机制，好像形同虚设，因为不管你是否登陆进去，只要登陆窗体被关闭</p><p>那么主窗体就会运行出来</p><p>网上提供的解决方案可以完美实现登陆窗口，所以先记下来：</p><p>第一种方法：</p><p>在主窗体的Load事件里面写</p><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        Form</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Form2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        f2.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ShowDialog</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (f2.DialogResult </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DialogResult.OK)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            MessageBox.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Show</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span></code></pre></div><p>然后在登陆窗体的按钮事件下写：</p><pre><code>        if (textBox1.Text == &quot;a&quot;)
        { //验证密码
            this.DialogResult = DialogResult.OK; //返回一个登录成功的对话框状态
            this.Close(); //关闭登录窗口
        }
</code></pre><p>主要原理就是利用的DialogResult = DialogResult.OK来实现的，<br> 首先程序在主加载form1时会触发load事件，然后主form1就会new一个form2并弹出登陆窗口，在登陆窗口验证密码正确以后设置DialogResult.OK这 一句，再将对话框关闭。</p><p>关闭以后from_load方法继续运行判断弹出的登陆框form2的DialogResult是否是ok，如果是，则加载主表 单，如果否，则关闭主表单</p><p>第二种方法：</p><p>直接在应用程序的主入口点</p><p>将mian方法改写成 ：</p><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        Form</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Form2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        f2.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ShowDialog</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (f2.DialogResult </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DialogResult.OK)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Application.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Form1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>登陆窗体的按钮事件同上写</p><p>主要原理就是在main方法运行的时候就先加载form2登陆框进行验证，如果验证通过才run（new form1（））。如果不通过则返回。</p>`,23),h=[l];function t(k,e,E,r,d,g){return a(),i("div",null,h)}const y=s(p,[["render",t]]);export{c as __pageData,y as default};
