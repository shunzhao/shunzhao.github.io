import{_ as t,c as a,o,a3 as i}from"./chunks/framework.Cv3JQ2Vj.js";const d=JSON.parse('{"title":"数据库扩容之翻倍扩容法","description":"","frontmatter":{"title":"数据库扩容之翻倍扩容法","date":"2024-08-11T00:00:00.000Z"},"headers":[],"relativePath":"posts/shu-ju-ku-kuo-rong-zhi-fan-bei-kuo-rong-fa.md","filePath":"posts/shu-ju-ku-kuo-rong-zhi-fan-bei-kuo-rong-fa.md"}'),e={name:"posts/shu-ju-ku-kuo-rong-zhi-fan-bei-kuo-rong-fa.md"},s=i('<h1 id="数据库扩容之翻倍扩容法" tabindex="-1">数据库扩容之翻倍扩容法 <a class="header-anchor" href="#数据库扩容之翻倍扩容法" aria-label="Permalink to &quot;数据库扩容之翻倍扩容法&quot;">​</a></h1><p>上个月例行周会上领导分享了一下其他小组的一些技术经验，其中有一个知识点讲的是数据库在分库分表下扩容的方案。这个方案之前确实没有了解过的，特此记录下来。</p><p>翻倍扩容法，也叫从库扩容法，每次都扩容上一次的二倍而得名。</p><p>大致的过程如下：</p><p>假设目前是三个数据库，业务根据 ID 取模决定要写入的数据库，于是最初的模型如下，但随着数据的增加，逐渐达到了单库的瓶颈，于是可以采用以下方式进行扩容：</p><p><img src="https://static.naidie.com/2024/08/11/1723362253.png" alt="img1"></p><p>之后让 DBA 先去配置同等数量的从库，并通过主从复制的方案把数据拷贝到从库上，此时从库是禁止读的，业务也只可能操作主库。</p><p><img src="https://static.naidie.com/2024/08/11/1723362319.png" alt="img2"></p><p>等到从库和主库的数据差不多完全一致时，再找个数据量小的时候把<strong>主库禁止写入</strong>，这一步是为了保证主库和从库的数据完全一致，当时会上讲的是可以不需要关闭主库，但是万一在<strong>从库切换为主库的过程中</strong>，主库有写入操作，此时没同步的话，那么两边的数据就对不齐了，所以为了保险一点，还是建议短暂关闭主库。</p><p>之后就是从库升级为主库，然后此时的模型变为如下：</p><p><img src="https://static.naidie.com/2024/08/11/1723362538.png" alt="img3"></p><p>但目前只扩容了库的数量，数据的大小并没有变化，每个库中有一半都是重复数据，读写速度依旧不会变化，所以后续需要走定时任务删除对应访问不到的数据，最终达到如下的效果。</p><p><img src="https://static.naidie.com/2024/08/11/1723362853.png" alt="img4"></p><h3 id="那如果扩容的数量不是-n-的倍数-会出现什么情况" tabindex="-1">那如果扩容的数量不是 N 的倍数，会出现什么情况？ <a class="header-anchor" href="#那如果扩容的数量不是-n-的倍数-会出现什么情况" aria-label="Permalink to &quot;那如果扩容的数量不是 N 的倍数，会出现什么情况？&quot;">​</a></h3><p><img src="https://static.naidie.com/2024/08/11/1723362933.png" alt="img5"></p><p>可以看到取模后访问到的 DB 都读取不到对应值。</p>',16),n=[s];function p(r,c,h,u,g,_){return o(),a("div",null,n)}const l=t(e,[["render",p]]);export{d as __pageData,l as default};
