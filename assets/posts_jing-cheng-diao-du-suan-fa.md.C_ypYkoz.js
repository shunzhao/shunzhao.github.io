import{_ as a,c as l,o as i,a3 as e}from"./chunks/framework.Cv3JQ2Vj.js";const f=JSON.parse('{"title":"进程调度算法","description":"","frontmatter":{"title":"进程调度算法","date":"2020-03-28T00:00:00.000Z"},"headers":[],"relativePath":"posts/jing-cheng-diao-du-suan-fa.md","filePath":"posts/jing-cheng-diao-du-suan-fa.md"}'),t={name:"posts/jing-cheng-diao-du-suan-fa.md"},o=e('<h1 id="进程调度算法" tabindex="-1">进程调度算法 <a class="header-anchor" href="#进程调度算法" aria-label="Permalink to &quot;进程调度算法&quot;">​</a></h1><h2 id="服务时间" tabindex="-1">服务时间 <a class="header-anchor" href="#服务时间" aria-label="Permalink to &quot;服务时间&quot;">​</a></h2><p>进程的执行需要的时间，比如考试时间为10点00：11点30，即服务时间就是90分钟</p><h2 id="周转时间" tabindex="-1">周转时间 <a class="header-anchor" href="#周转时间" aria-label="Permalink to &quot;周转时间&quot;">​</a></h2><p>执行从提交到执行完所花费的时间，比如考试时间为10:00-11:30，但我是9:30到的，那么一直到考试结束，我一共花了120分钟</p><h2 id="剥夺与非剥夺" tabindex="-1">剥夺与非剥夺 <a class="header-anchor" href="#剥夺与非剥夺" aria-label="Permalink to &quot;剥夺与非剥夺&quot;">​</a></h2><ul><li>非剥夺 <ul><li>资源在我手上，只要我不主动放弃，那么谁也拿不走。</li><li>比如排队的时候，下一个就是你，这时候只要你不主动放弃，下一个一定是你。</li></ul></li><li>剥夺 <ul><li>资源在你手上，但有可能被高优先级的抢走。</li><li>比如排队的时候，下一个就是你，这时候VIP来了，你就有可能被打断，让VIP优先执行。</li></ul></li></ul><h2 id="先来先服务" tabindex="-1">先来先服务 <a class="header-anchor" href="#先来先服务" aria-label="Permalink to &quot;先来先服务&quot;">​</a></h2><p>总是执行排在队首的任务，生活总到处可以看得到这种算法，食堂打饭、超市结账等等。</p><ul><li><p>优点</p><ul><li>最常见，最容易实现</li></ul></li><li><p>缺点</p><ul><li>系统资源的利用率不高</li><li>吞吐量小</li><li>比如你去超市就为了买瓶水，结果前面排了20个人，都是满满的购物车，你会怎么样？估计就换一家买了，所以很显然等待时间长，服务时间短，不划算。</li></ul></li></ul><h2 id="短进程优先" tabindex="-1">短进程优先 <a class="header-anchor" href="#短进程优先" aria-label="Permalink to &quot;短进程优先&quot;">​</a></h2><p>上面的算法，对服务时间短进程不利，改进的方法：从队列中取服务时间最短的进程优先执行</p><ul><li>优点 <ul><li>吞吐量大，在一段时间内执行的任务多</li></ul></li><li>缺点 <ul><li>服务时间长的进程有可能长时间得不到调度</li></ul></li></ul><h2 id="轮转调度" tabindex="-1">轮转调度 <a class="header-anchor" href="#轮转调度" aria-label="Permalink to &quot;轮转调度&quot;">​</a></h2><p>采用执行时间片的方法，从就绪队列队首获取一个进程开始执行，执行一个时间片后如果该进程未执行完，则将该进程放到队尾，如果执行完了将该进程移除就绪队列。</p><ul><li>优点 <ul><li>解决了先来先服务算法中可能短进程长时间得不到执行的问题</li></ul></li><li>缺点 <ul><li>进程多，等的时间长，比如IO和计算</li></ul></li></ul>',16),r=[o];function n(u,h,s,d,c,p){return i(),l("div",null,r)}const m=a(t,[["render",n]]);export{f as __pageData,m as default};
