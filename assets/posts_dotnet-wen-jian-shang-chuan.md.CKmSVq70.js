import{_ as t,c as e,o,a3 as a}from"./chunks/framework.Cv3JQ2Vj.js";const g=JSON.parse('{"title":".net 文件上传","description":"","frontmatter":{"title":".net 文件上传","date":"2018-03-16T00:00:00.000Z"},"headers":[],"relativePath":"posts/dotnet-wen-jian-shang-chuan.md","filePath":"posts/dotnet-wen-jian-shang-chuan.md"}'),i={name:"posts/dotnet-wen-jian-shang-chuan.md"},n=a('<h1 id="net-文件上传" tabindex="-1">.net 文件上传 <a class="header-anchor" href="#net-文件上传" aria-label="Permalink to &quot;.net 文件上传&quot;">​</a></h1><p>昨天学习了.net的文件上传。原来在寒假学习其他语言文件上传的时候，视频中的老师就讲过，对于用户上传的文件需要处理，不仅仅是限制文件大小，文件类型的上传，还要处理同名文件的情况。假如用户甲先上传了一个文件为 1.jpg ，用户乙也上传了一个文件为 1.jpg ，那么很有可能用户乙上传的文件会覆盖掉用户甲上传的文件，那么用户甲在取文件的时候取的是用户乙的文件。这是一个很大的BUG，很有趣的是，我们的老师并没有提到这一点。</p><p>至于处理这BUG有很多种方法，比如可以说对每个用户单独创建文件夹，也可以随机生成文件名字。最后不放心甚至还可以加上判断文件是否存在，这样就可以完全避免上面所说的情况。</p><p>我采用的方法是 创建当前 年/月/日/的文件夹 加上 采取当前时分秒 和随机数的方式来作为文件名来避免这种情况。</p><p>附上代码:</p><p>前端控件代码</p><p>&lt;asp:FileUpload ID=&quot;FileUpload&quot; runat=&quot;server&quot; /&gt; &lt;asp:Button ID=&quot;submit&quot; runat=&quot;server&quot; Text=&quot;上传&quot; OnClick=&quot;submit_Click&quot; /&gt;</p><p>后端逻辑代码</p><p>bool b = false; //检测FileUpload文件上传控件是否选择了文件 if (FileUpload.HasFile) { //获取文件后缀 string filetype = System.IO.Path.GetExtension(FileUpload.FileName); string[] type = { &quot;.jpg&quot;, &quot;.jpeg&quot;, &quot;.png&quot;, &quot;.gif&quot;, &quot;.bmp&quot; }; for (int i = 0; i &lt; type.Length; i++) { //循环判断文件后缀与数组值匹配 if (type[i] == filetype) { b = true; } } if (b) { //先将文件保存到临时目录 其实这步完全没必要 但是为什么要这么做，其实是某最好的语言的强迫症啊，懂得自然懂。 FileUpload.SaveAs(Server.MapPath(&quot;~/temp/&quot; + FileUpload.FileName)); //拼接当前带年月日的文件目录 string FileDatePath = Server.MapPath(&quot;~/images/&quot;) + DateTime.Now.ToString(&quot;yyyy&quot;) + &quot;\\\\&quot; + DateTime.Now.ToString(&quot;MM&quot;) + &quot;\\\\&quot; + DateTime.Now.ToString(&quot;dd&quot;);<br> //拼接当前带时分秒的字符串 string time = DateTime.Now.ToString(&quot;HHmmss&quot;); //生成1,1000的随机数 用于后面拼接文件名 Random rands = new Random(); string rand = rands.Next(1, 1000).ToString(); //判断目录是否存在<br> if (!Directory.Exists(FileDatePath)) { System.IO.Directory.CreateDirectory(FileDatePath); } //获取文件所在的目录 string fileurl = Server.MapPath(&quot;~/temp/&quot; + FileUpload.FileName); /* *移动文件到当前年月日的文件夹中，并且文件名为当前时分秒加上随机数1-1000 *这样就是为了防止用户同时上传或文件同名导致的文件丢失 *最终文件所在的目录列如 web程序\\\\images\\\\2018\\\\03\\\\16\\\\202534176.png(20为20时 25为25分钟 34为34秒 176为随机数) *这样再同一秒中上传导致的文件同名的机率大大降低 */ //移动文件 File.Move(fileurl, FileDatePath + &quot;\\\\&quot; + time + rand + filetype); Response.Write(&quot;&quot;); } else { Response.Write(&quot;&quot;); } }</p>',9),r=[n];function u(s,p,l,q,d,m){return o(),e("div",null,r)}const h=t(i,[["render",u]]);export{g as __pageData,h as default};
