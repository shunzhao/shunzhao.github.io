import{_ as e,c as a,o,a3 as t}from"./chunks/framework.Cv3JQ2Vj.js";const m=JSON.parse('{"title":"TCP的三次握手和四级挥手","description":"","frontmatter":{"title":"TCP的三次握手和四级挥手","date":"2021-09-02T00:00:00.000Z"},"headers":[],"relativePath":"posts/tcp-de-san-ci-wo-shou-he-si-ji-hui-shou.md","filePath":"posts/tcp-de-san-ci-wo-shou-he-si-ji-hui-shou.md"}'),i={name:"posts/tcp-de-san-ci-wo-shou-he-si-ji-hui-shou.md"},n=t('<h1 id="tcp的三次握手和四级挥手" tabindex="-1">TCP的三次握手和四级挥手 <a class="header-anchor" href="#tcp的三次握手和四级挥手" aria-label="Permalink to &quot;TCP的三次握手和四级挥手&quot;">​</a></h1><h2 id="tcp三次握手的过程" tabindex="-1">TCP三次握手的过程 <a class="header-anchor" href="#tcp三次握手的过程" aria-label="Permalink to &quot;TCP三次握手的过程&quot;">​</a></h2><ol><li><p>首先我们看看TCP头部，其大致信息为：</p><ol><li>source Port（我们的端口地址）</li><li>destination Port （对方的端口地址）</li><li>sequence number （目前发送的数据偏移量，随机的一个序号）</li><li>acknowledge number （已经收到了多少的数据偏移量）</li><li>flag标志位 （控制信息的状态位，连接时syn标志位设置为1） <ol><li>reduce（拒绝连接）</li><li>acknowledge（acknowledge number有效）</li><li>push（代表将缓存区的数据强制发送）</li><li>syn（代表同步请求，可以理解为连接请求）</li><li>fin（代表某一方不再继续发送数据了）</li></ol></li></ol><p>需要重点注意的是<strong>sequence number</strong>、<strong>acknowledge number</strong>以及相关标志位，下面就重点介绍相关知识。</p></li><li><p>sequence number</p><p>数据包在传输的时候会有一个大小的限制，这个限制取决于以太网规定的MTU（最大传输单元）1500字节，因为还要加上TCP头部，IP头部，MAC头部，最终实际传输数据的大小其实是不足1500字节。</p><p>如果我们的一个网页传输的数据大小超过1500字节，那么该数据就要被分割成一个个小的数据包进行传输，那么问题来了，如何让对方知道，接受到的数据包是整个数据的第几个呢？sequence number就是来解决这一问题的。</p><p>第一次发送数据时sequence number为0，数据长度为1000，对方收到后就知道将这个数据包存放在偏移地址为0的地方，</p><p>第二次发送数据时sequence number为1001，数据长度为1000，对方收到后就知道将这个数据包存放在偏移地址为1001的地方。</p></li><li><p>acknowledge number</p><p>TCP号称是可靠传输，那么是如何保证的呢？其实就是acknowledge number了，在接收到对方发来的数据后，就需要告知对方，我到目前为止收到了多长的数据，并且期待下一次接受的包的偏移地址，比如在上面，我收到了sequence number为0，数据长度为1000的数据后，我就需要回复acknowledge number：1001，代表我收到了，1000之前的所有包，并且下一个数据应该是1001开头，客户端在收到了后，就会进行验证，我下一个发送的数据确实应该是1001开头，这就说明对方正确无误的接收到了！</p><h5 id="可是如果不是1001开头怎么办" tabindex="-1">可是如果不是1001开头怎么办？ <a class="header-anchor" href="#可是如果不是1001开头怎么办" aria-label="Permalink to &quot;可是如果不是1001开头怎么办？&quot;">​</a></h5><p>​ 客户端会间隔一段时间后再次发送数据，为什么要间隔一段时间呢？因为上一个数据包丢失可能是网络堵塞或其他问题，这时再立即发送数据，只会堵上添堵。</p><h5 id="假如就是网络堵塞问题-导致对方收到两个一样的包怎么办" tabindex="-1">假如就是网络堵塞问题，导致对方收到两个一样的包怎么办？ <a class="header-anchor" href="#假如就是网络堵塞问题-导致对方收到两个一样的包怎么办" aria-label="Permalink to &quot;假如就是网络堵塞问题，导致对方收到两个一样的包怎么办？&quot;">​</a></h5><p>​ 服务器收到后会进行检查，如果收到了相同的包会丢弃，不会造成错误！</p></li><li><p>flag标志位</p><p>在连接时，一定要设置syn表示为1，然后其余的每次请求，ack标识位都为1。</p></li></ol><h2 id="tcp的四次挥手" tabindex="-1">TCP的四次挥手 <a class="header-anchor" href="#tcp的四次挥手" aria-label="Permalink to &quot;TCP的四次挥手&quot;">​</a></h2><p>TCP是全双工模式，意味着通信的两端可以同时发送或接受数据，假如某一端想要断开连接，那么其会将TCP控制位中的Fin标识位，置为1，表示通知对方我将没有信息发送了，对方收到后会回复ACK包，表示我知道了，等到接收方的操作完成也没有数据发送后，也会给对方发送一个Fin标识为1的包，对方收到后回复ACK包，至此TCP的连接就断开了，但并不会立即销毁Socket。</p><h4 id="sequence为什么是随机的" tabindex="-1">sequence为什么是随机的？ <a class="header-anchor" href="#sequence为什么是随机的" aria-label="Permalink to &quot;sequence为什么是随机的？&quot;">​</a></h4><p>从安全性的角度来看，可以防止黑客恶意拦截包或发送包。</p><h4 id="为什么要三次握手-syn只被设置了两次-那么两次握手行不行" tabindex="-1">为什么要三次握手，SYN只被设置了两次，那么两次握手行不行？ <a class="header-anchor" href="#为什么要三次握手-syn只被设置了两次-那么两次握手行不行" aria-label="Permalink to &quot;为什么要三次握手，SYN只被设置了两次，那么两次握手行不行？&quot;">​</a></h4><p>​ 其实是为了确保服务器资源不会被浪费，假设客户端发送一个连接的请求，但不幸的是，网络堵塞了，客户端迟迟没有收到服务端的回复信息，于是<strong>再次发送了一次连接请求</strong>，这次很顺利，双方建立了连接，而后面第一次的请求到了，服务端会以为客户端又发送了一个新的连接请求，于是和客户端建立新的连接，但这个连接客户端并不知道，也不会使用，这就意味着服务的这个线程被浪费了，严重会导致单进程死锁。</p><h4 id="为什么tcp断开后-不会立即销毁socket" tabindex="-1">为什么TCP断开后，不会立即销毁Socket？ <a class="header-anchor" href="#为什么tcp断开后-不会立即销毁socket" aria-label="Permalink to &quot;为什么TCP断开后，不会立即销毁Socket？&quot;">​</a></h4><p>​ 假设客户端给服务器端发送了FIN终止包，之后服务端完成操作后给客户端发送了FIN包，等待客户端回复，然而这个包因为网络堵塞的问题没能及时到达客户端，服务端等待一段时间后以为包，会丢失重新发送，重新发送的包很快就到达了客户端，此时客户端回复ACK包，TCP断开且Socket销毁，然而刚好另一个客户端采用了同样的IP和端口建立了连接，雪上加霜的是，上一个FIN包到达了客户端，此时客户端就会以为服务器端申请断开连接，导致这个刚建立的连接就被断开浪费资源。</p>',11),l=[n];function r(s,c,h,p,u,d){return o(),a("div",null,l)}const b=e(i,[["render",r]]);export{m as __pageData,b as default};
