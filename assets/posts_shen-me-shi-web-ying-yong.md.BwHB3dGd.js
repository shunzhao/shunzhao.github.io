import{_ as e,c as a,o as t,a3 as o}from"./chunks/framework.Cv3JQ2Vj.js";const m=JSON.parse('{"title":"什么是 Web 应用？","description":"","frontmatter":{"title":"什么是 Web 应用？","date":"2024-07-28T00:00:00.000Z"},"headers":[],"relativePath":"posts/shen-me-shi-web-ying-yong.md","filePath":"posts/shen-me-shi-web-ying-yong.md"}'),n={name:"posts/shen-me-shi-web-ying-yong.md"},s=o('<h1 id="什么是-web-应用" tabindex="-1">什么是 Web 应用？ <a class="header-anchor" href="#什么是-web-应用" aria-label="Permalink to &quot;什么是 Web 应用？&quot;">​</a></h1><p>今天了解到了一个新的概念：Web 应用，我最开始想着这不就是网页的另一个叫法吗？后面听了解释才发现确实是我孤陋寡闻了。</p><h2 id="什么是网页" tabindex="-1">什么是网页？ <a class="header-anchor" href="#什么是网页" aria-label="Permalink to &quot;什么是网页？&quot;">​</a></h2><p>这里的网页主要是讲的是传统网页，也就是打开浏览器，然后输入一个网址，浏览器就呈现出对应的页面，这种的就是网页。</p><h2 id="什么是-web-应用-1" tabindex="-1">什么是 Web 应用？ <a class="header-anchor" href="#什么是-web-应用-1" aria-label="Permalink to &quot;什么是 Web 应用？&quot;">​</a></h2><p>而 Web 应用是指用传统的 Web 前端技术：HTML、CSS、JS，构建的桌面应用，这里的重点在于<strong>应用</strong>两个字，也就是说它是可以<strong>安装</strong>到本地使用的。</p><h2 id="网页和-web-应用的区别" tabindex="-1">网页和 Web 应用的区别 <a class="header-anchor" href="#网页和-web-应用的区别" aria-label="Permalink to &quot;网页和 Web 应用的区别&quot;">​</a></h2><p>传统网页侧重点在于服务器端，因此大量计算一般都在服务器端实现，而随着 NodeJS 的出现，JS 不在拘束于浏览器的安全约束，变得可以访问本地计算机资源，实现像文件读写等功能，于是可以让计算由服务器端转到本地来完成，<strong>无需每次都向服务器端去请求获取数据</strong>，等到真正需要大量计算的地方再去传到云端，让众多的云服务器去参与计算再传回，这使得 Web 应用从体验上来说比传统的桌面应用差不了多少，甚至有时候体验会更棒。将传统网页用的技术复制到桌面开发上面来，既不需要开发者学习多门语言。并且维护也变简单了，原来可能有两套交互逻辑，现在网页和桌面使用一套交互逻辑实现统一。</p><p>所以目前也会发现越来越多的传统应用都逐渐开始迭代为 Web 应用了，比如开发者熟悉的 Visual Studio Code、大众更熟悉的 QQ、UI 使用比较多的 Figma 等，他们都算的上是 Web 应用，甚至现如今 Chrome 浏览器 从 124 版本允许将某个网页安装为应用。 <img src="https://s2.loli.net/2024/07/28/845AxSMzRHa2BDY.png" alt="image.png"></p><h2 id="实现原理" tabindex="-1">实现原理 <a class="header-anchor" href="#实现原理" aria-label="Permalink to &quot;实现原理&quot;">​</a></h2><p>本质就是将 JS 运行环境内嵌为一个应用，可以简单理解为这个应用就是一个浏览器，只是这个浏览器只能访问特定的网页。比如上面说的 QQ、Visual Studio Code、Figma 等它们就使用了同一套框架 Electron。</p>',11),r=[s];function i(h,l,b,d,c,p){return t(),a("div",null,r)}const g=e(n,[["render",i]]);export{m as __pageData,g as default};
