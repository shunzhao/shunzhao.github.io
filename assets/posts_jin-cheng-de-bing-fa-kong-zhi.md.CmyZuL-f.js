import{_ as s,c as i,o as a,a3 as n}from"./chunks/framework.Cv3JQ2Vj.js";const c=JSON.parse('{"title":"进程的并发控制","description":"","frontmatter":{"title":"进程的并发控制","date":"2022-03-01T00:00:00.000Z"},"headers":[],"relativePath":"posts/jin-cheng-de-bing-fa-kong-zhi.md","filePath":"posts/jin-cheng-de-bing-fa-kong-zhi.md"}'),h={name:"posts/jin-cheng-de-bing-fa-kong-zhi.md"},l=n(`<h1 id="进程的并发控制" tabindex="-1">进程的并发控制 <a class="header-anchor" href="#进程的并发控制" aria-label="Permalink to &quot;进程的并发控制&quot;">​</a></h1><h2 id="什么是并发控制" tabindex="-1">什么是并发控制？ <a class="header-anchor" href="#什么是并发控制" aria-label="Permalink to &quot;什么是并发控制？&quot;">​</a></h2><p>指的是多个进程在访问某一个资源时，因操作系统调度的问题，我们无法确定进程执行的先后顺序，因此为了保证结果的准确性就需要并发控制，实现并发控制的两点就是<strong>互斥与同步</strong>。</p><h2 id="互斥与同步" tabindex="-1">互斥与同步 <a class="header-anchor" href="#互斥与同步" aria-label="Permalink to &quot;互斥与同步&quot;">​</a></h2><p>互斥只是某一个资源一次只能有一个进程可以访问，而同步则是在互斥之上保证进程执行的顺序。</p><h2 id="互斥的规则" tabindex="-1">互斥的规则 <a class="header-anchor" href="#互斥的规则" aria-label="Permalink to &quot;互斥的规则&quot;">​</a></h2><p>空闲让进：当前资源无人使用的时候，可以让进程占用着。</p><p>忙则等待：当前资源已经被别的进程使用了，则需要等待该资源释放。</p><p>有限等待：虽然等待该资源释放才能使用，但是也不能无限的等待下去，不然该进程就死锁了。</p><p>让权等待：让权不是让给权力更高的进程，指的是当进程无法进入到临界区时应该及时退出来。</p><h2 id="并发控制的实现方法" tabindex="-1">并发控制的实现方法 <a class="header-anchor" href="#并发控制的实现方法" aria-label="Permalink to &quot;并发控制的实现方法&quot;">​</a></h2><h3 id="硬件实现" tabindex="-1">硬件实现 <a class="header-anchor" href="#硬件实现" aria-label="Permalink to &quot;硬件实现&quot;">​</a></h3><ol><li>关中断，在当前程序执行过程中，不会被打断，知道该程序执行完成。</li><li>机器语言，设计一个专用的机器指令，因为在单条机器指令执行期间是无法被打断的(中断则是在每条指令执行完成后才会去检测)</li></ol><h3 id="软件实现" tabindex="-1">软件实现 <a class="header-anchor" href="#软件实现" aria-label="Permalink to &quot;软件实现&quot;">​</a></h3><p>基本概念：</p><ol><li><p>信号量</p><p>信号量可以理解为是一个特殊的变量类型，它拥有一个整数的值和一个队列。</p></li><li><p>原语操作</p></li></ol><p>原语操作是指封装的一组指令，在这一组指令的过程中不可被打断，即要么都执行要么都不执行(熟悉吧，事务的原子性)，其实可以简单的理解为将执行一组单个指令的之前关闭了中断。</p><p>实现过程：</p><p>比如封装了两个原语操作，一个称为：wait，另外一个称为signal</p><p>wait的伪代码为：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //信号量的整数变量</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> queue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 信号量的队列</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //阻塞自己，并且将自己加入到s2队列中</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>signal的伪代码为：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //信号量的整数变量</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> queue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 信号量的队列</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">signal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //唤醒queue的第一个进程，将其移除队列</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol><li><p>资源信号量</p><p>只是有多个资源可以被同时使用。</p></li><li><p>互斥信号量</p></li></ol><h2 id="临界资源" tabindex="-1">临界资源 <a class="header-anchor" href="#临界资源" aria-label="Permalink to &quot;临界资源&quot;">​</a></h2><p>对于<strong>一次仅允许一个进程</strong>使用的资源称为临界资源</p><h2 id="临界区" tabindex="-1">临界区 <a class="header-anchor" href="#临界区" aria-label="Permalink to &quot;临界区&quot;">​</a></h2><p><strong>每个进程中访问临界资源的那段代码称为临界区</strong></p>`,28),t=[l];function p(e,k,r,d,E,o){return a(),i("div",null,t)}const y=s(h,[["render",p]]);export{c as __pageData,y as default};
