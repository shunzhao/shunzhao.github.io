import{_ as e,c as a,o as s,a3 as t}from"./chunks/framework.Cv3JQ2Vj.js";const k=JSON.parse('{"title":"Tomcat配置文件浅解析","description":"","frontmatter":{"title":"Tomcat配置文件浅解析","date":"2022-03-07T00:00:00.000Z"},"headers":[],"relativePath":"posts/tomcat-pei-zhi-wen-jian-qian-jie-xi.md","filePath":"posts/tomcat-pei-zhi-wen-jian-qian-jie-xi.md"}'),i={name:"posts/tomcat-pei-zhi-wen-jian-qian-jie-xi.md"},n=t(`<h1 id="tomcat配置文件浅解析" tabindex="-1">Tomcat配置文件浅解析 <a class="header-anchor" href="#tomcat配置文件浅解析" aria-label="Permalink to &quot;Tomcat配置文件浅解析&quot;">​</a></h1><p>Tomcat也叫Servlet容器，同时兼顾HTTP服务器的作用，他首先接受HTTP请求，然后根据Web.xml文件中的配置，找到对应的Servlet并实例化，最后通过URL调用执行Servlet中的service方法，返回结果给用户。</p><p>Tomcat主要有三个文件需要注意：</p><h2 id="web-xml" tabindex="-1">Web.xml <a class="header-anchor" href="#web-xml" aria-label="Permalink to &quot;Web.xml&quot;">​</a></h2><p>Web.xml文件中主要存储了Servlet和URI，并将双方映射起来，这样就知道哪个URL调用哪个Servlet了，在Tomcat中也有这个文件，他是所有WebApp的父亲，也就是说所有的Web.xml都继承自它，它默认有两个Servlet：</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">1. defaultServlet&lt;——&gt;/ 默认的Servlet，当没有对应的URL的Servlet时，则有该Servlet处理</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">2. JspServlet &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">----</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; 用于处理Jsp后缀的请求，处理所有的JSP页面</span></span></code></pre></div><p>同时Web.xml还设置了对应文件的mine类型，以及默认的欢迎页面是什么。</p><p>Context.xml</p><p>配置了应用的上下文。</p><p>Server.xml</p><p>Tomcat的主要配置文件。其中主要有以下：</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">1. Server 代表服务器自身，监听某个端口</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">2. Service 代表一个服务</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">3. Connector 代表接收请求和返回响应的服务监听程序，通常监听80端口，可以理解为网络中的网卡模块，路由器的作用。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">4. Engine 代表所有请求的服务处理程序，Connector监听到请求后，就将请求转发给Engine处理，Engine可以独立的分析请求中包含的HTTP头部，并转发给合适的Host，可以理解为交换机或者IP模块。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">5. Host 代表某一个APP，一台Web服务器上可以同时运行多个网站，也叫虚拟主机，因此Engine需要根据域名来匹配对应的HOST，相当于交换机要根据MAC地址找到对应的机器处理。</span></span></code></pre></div>`,12),l=[n];function p(o,c,r,h,d,m){return s(),a("div",null,l)}const g=e(i,[["render",p]]);export{k as __pageData,g as default};
